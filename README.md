## 什么是控制反转（Inversion of Control -> IoC）

广义上，控制反转是指在一个控制关系中，控制者与被控制者关系调换了（反转），原来是控制者控制被控制者，控制反转之后，是被控制者控制了控制者。  

举个简单的例子，某餐厅垄断了小区饮食，每天提供固定的午餐样式，今天A餐，明天B餐。这个时候餐厅控制了顾客每天吃什么。顾客想自主点餐，在垄断市场中，没门，爱吃不吃。  

后来有了外卖点餐，外部餐厅可以送餐上门了！垄断市场被打破了。顾客对餐厅老板说，老板我想要自主点餐，我要C餐，D餐，你不提供的话，我就点外卖了。老板为了挣钱，适应了市场变化，支持了自主点餐。  

于是，顾客通过点餐控制了自已每天吃什么，可以去餐厅点餐，也可以点外卖，实现了吃饭自由（说得好像真的一样）。  

这时，控制关系发生了变化，我们称之为控制反转。

## 什么是依赖关系

在面对对象编程中，依赖关系从依赖的角度来描述控制关系。A依赖于B，是指A以B为前提，为条件而存在或行动。  

在上述例子中，初始是餐厅控制顾客吃什么，从依赖关系的角度来描述的话，是顾客依赖于餐厅，顾客能吃到什么，是以餐厅安排的样式为前提的。  

控制反转之后，顾客可以自助点餐，顾客能吃什么不再依赖于餐厅。  

这时餐厅依赖于顾客，顾客点什么，餐厅就做什么。当然还有更大的前提，餐厅得有材料，也要会做……这里只关注顾客与餐厅的交互。 

## 关系的定义

关系是相互的，关系描述的是参与方之间的相互作用。依赖关系和控制关系只是我们描述关系的不同角度。  

当一个关系中，参与方的关系发生了调换，我们就说，关系发生了反转。  

在面向对象编程中，每个参与方都是一个对象。依赖倒置，控制反转，是我们从不同角度描述对象关系变化的一个“具体”词语。  

说它们具体，是指它们具体描述了哪种关系。依赖倒置描述的是依赖关系。控制反转描述的是控制关系。  

同时，它们也是抽象的。它们隐去了具体的参与方和反转的手段。到底有多少个参与方，谁控制谁，谁依赖谁，怎么实现反转的？这些信息已经被抽象、隐藏了。  

要想还原及了解背后更丰富的内涵，就会涉及到抽象、接口、继承、多态、设计原则、惯用法、设计模式等概念。  

在此我们就不一一展开了，我们先把控制反转说透。  


## 控制反转的分类

关系又可以层级关系和平等关系。  

发生在层级关系中的控制反转，我们称之为依赖倒置。上下分层的依赖关系发生控制反转的表现就像上下颠倒一样，依赖倒置了。  

一般而言，我们说控制反转时，指的是发生在平等关系中的控制反转，具体表现是控制流程发生了变化。  

常见地，我们可以通过将轮询方式转变为事件驱动，以实现控制流反转。  

这种策略可以说在编程世界中随处可见。观察者模式，IO复用模型到信号驱动IO模型的演变都使用了这种策略。  

我们可以通过点餐候餐的例子，对这种策略进行简单的说明。  

点餐后在等待上菜时，有时候等太久了，我们会不断地问服务员，菜好了吗，什么时候可以上。这种不断地询问是否达到条件（菜好了吗），就是轮询方式。  

后来服务员说，不要问了，我现场给你盯着，菜好了马上给您送上来。这时就变成了事件驱动（事件：菜做好了）。  


## 什么是依赖注入

依赖注入是对创建对象这一过程实现控制反转的一个手段。  

我们首先明确一点，依赖注入是针对对象创建和对象管理这一过程的。  

通常情况下，我们在一行代码里通过new指令来对象创建和赋值。  

我们又拿点餐举个例子。例如我们在餐厅里点了一碗面，于是厨房开始煮面，伪代码如下：
```
Food food = new Noodle();
```
这个时候代码是直接引用并依赖于Noodle这个类的，假如我们下一次点了饺子，那么厨房代码得改了，伪代码如下：
```
Food food = new Dumpling();
```
如果我们不断地换食物品种，那厨房的代码得不断地改，这就很麻烦了。厨房代码创建食物的过程与具体实现类耦合度太高，扩展性很差。

耦合度太高，扩展性很差，这在现实生活中怎么理解呢?就像你在中餐厅里点西餐，在烧烤店里点火锅一样。这个生意大部分情况下是没法做，顾客得换店了，对吧？

那么我们怎么做到低耦合，高扩展，让顾客想吃啥都不换店呢？

这就需要依赖注册-依赖查找-依赖注入了！

说人话？

翻译一下。  

依赖注册就是提供一个注册中心，登记具体的实现类（依赖）。对应于点餐的例子就是，创建一个服务平台，各种大厨、餐厅会做什么食物都来这里登记。

依赖查找就是根据依赖名称，到注册中心找想要的依赖，并建立链接。对应于点餐的例子就是，来服务平台通过食物名订餐，服务平台自行匹配对应的大厨和餐厅。

依赖注入就是注册中心找到你需要的依赖，帮你完成对象创建与赋值。对应于点餐的例子就是，服务平台匹配到的大厨和餐厅准备好食物后，送货上门。

这都是啥呀？最终变成上某app点外卖？

但你发现没有，某app虽然不会下厨，但它通过提供依赖注册（厨师、厨房、餐厅可供菜品登记）-依赖查找（搜索匹配）-依赖注入（送货到家），提供了几乎的万能食品供应。使用某app是不是可以通吃所有食品品种？

这就是低耦合，高扩展。

## IoC与依赖注入的成本
IoC与依赖注入那么好，是不是一定要用，到处都用？  

不是的。IoC与依赖注入由于引入了第三方进行关系管理、对象创建、对象赋值，创建对象的链路延长了，使用的技术复杂了，需要的性能消耗也增加了。

大白话就是，点外卖不要服务费呀？

## 干货水货分界线--------------大白话与技术分割线---------------
讲了那么多，直接来硬货了。  
通俗易懂的背后是，实践出真知。 

## 怎么实现IoC和依赖注入
* 定义基本元素(定义注解Component)  
* 定义关系注册方式（定义注解Autowired）  
* 在具体类中登记名称（使用注解Component）
* 在应用类中登记关系（使用注解Autowired)
* 注册中心扫描具体类，完成类加载，根据Component注解，建立名称与实现类的映射关系
* 注册中心扫描应用类，根据Autowired注解，完成实现类查找、创建对象、完成依赖注入


## 项目简单地展示了Spring实现IoC和依赖注入的基本过程。

项目中包含两个入口类，分别为RunWithIoC和RunWithoutIoC。  

RunWithoutIoC展示的是经典的开发流程，UserServiceImplWithOutIoC自已创建对象并完成赋值，UserServiceWithOutIoC直接与具体的IUserDao耦合，表现了较强的依赖性。  

RunWithIoC使用了IoC和依赖注入进行对象管理，使UserServiceImplWithIoc不直接依赖于具体的IUserDao，从创建对象的源头上实现了解耦。  
